"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _defineProperty2 = require("babel-runtime/helpers/defineProperty");

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _chalk = require("chalk");

var _chalk2 = _interopRequireDefault(_chalk);

var _lodash = require("lodash");

var _fsExtra = require("fs-extra");

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _moment = require("moment");

var _moment2 = _interopRequireDefault(_moment);

var _ora = require("ora");

var _ora2 = _interopRequireDefault(_ora);

var _debug = require("./debug");

var debug = _interopRequireWildcard(_debug);

var _Utils = require("./Utils");

var _Utils2 = _interopRequireDefault(_Utils);

var _Github = require("./Github");

var _Github2 = _interopRequireDefault(_Github);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Version = function () {
  function Version(config, options) {
    var _incrementMap;

    (0, _classCallCheck3.default)(this, Version);

    this.config = (0, _extends3.default)({
      github: {},
      majorLabel: "Version: Major",
      minorLabel: "Version: Minor",
      patchLabel: "Version: Patch",
      internalLabel: "No version: Internal",
      abortOnMissingLabel: false
    }, config);
    this.options = (0, _extends3.default)({}, Version.defaultOptions, options);

    this.incrementMap = (_incrementMap = {}, (0, _defineProperty3.default)(_incrementMap, this.config.majorLabel, Version.INCREMENT_MAJOR), (0, _defineProperty3.default)(_incrementMap, this.config.minorLabel, Version.INCREMENT_MINOR), (0, _defineProperty3.default)(_incrementMap, this.config.patchLabel, Version.INCREMENT_PATCH), (0, _defineProperty3.default)(_incrementMap, this.config.internalLabel, Version.NO_INCREMENT), _incrementMap);

    var branch = _Utils2.default.getBranch();

    // force dry-run when not on the release-branch and !this.options.init
    if (!this.options.init && branch !== this.options.branch) {
      this.options.dryRun = true;
    }

    debug.info("Current branch: %s", branch);
    debug.info("Release branch: %s", this.options.branch);

    this.shouldPush = this.options.push || this.options.publish;
    this.shouldPublish = this.options.publish;

    if (this.options.dryRun) {
      debug.info("Dry-run enabled");
    }

    if (this.shouldPush) {
      debug.info("Version updates will be pushed to the repo");
    }

    if (this.shouldPublish) {
      debug.info("Version updates will be published to NPM");
    }
  }

  // returns the PR or commit with the increment level attached


  (0, _createClass3.default)(Version, [{
    key: "getLastChangeWithIncrement",
    value: function () {
      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
        var pr, commitSHA, commit;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                pr = _Utils2.default.getLastPullRequest();

                if (pr) {
                  _context.next = 8;
                  break;
                }

                commitSHA = _Utils2.default.getLastCommit();
                _context.next = 5;
                return this.getGithubAPI().getCommit(commitSHA);

              case 5:
                commit = _context.sent;


                if (this.config.abortOnMissingLabel) {
                  debug.warn("Only commits found. Aborting release based on config.");
                  commit.increment = Version.NO_INCREMENT;
                } else {
                  debug.warn("Only commits found. Defaulting to " + Version.INCREMENT_PATCH + ".");
                  commit.increment = Version.INCREMENT_PATCH;
                }

                return _context.abrupt("return", commit);

              case 8:
                _context.next = 10;
                return this.getIncrementFromPullRequest(pr);

              case 10:
                return _context.abrupt("return", _context.sent);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getLastChangeWithIncrement() {
        return _ref.apply(this, arguments);
      }

      return getLastChangeWithIncrement;
    }()

    // returns a pull request with increment level noted

  }, {
    key: "getIncrementFromPullRequest",
    value: function () {
      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(number) {
        var githubapi, prDetails, increment;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                githubapi = this.getGithubAPI();
                _context2.next = 3;
                return githubapi.getPullRequest(number);

              case 3:
                prDetails = _context2.sent;
                _context2.next = 6;
                return githubapi.getIssueLabels(number);

              case 6:
                prDetails.labels = _context2.sent;

                if (!prDetails.labels) {
                  _context2.next = 13;
                  break;
                }

                increment = this.getIncrementFromIssueLabels(prDetails);

                if (!increment) {
                  _context2.next = 13;
                  break;
                }

                debug.info("Found " + increment + " label on PR #" + number + ".");
                prDetails.increment = increment;

                return _context2.abrupt("return", prDetails);

              case 13:

                if (this.config.abortOnMissingLabel) {
                  debug.warn("No labels found on PR #" + number + ". Aborting release based on config.");
                  prDetails.increment = Version.NO_INCREMENT;
                } else {
                  debug.warn("No labels found on PR #" + number + ". Defaulting to " + Version.INCREMENT_PATCH + ".");
                  prDetails.increment = Version.INCREMENT_PATCH;
                }

                return _context2.abrupt("return", prDetails);

              case 15:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getIncrementFromPullRequest(_x) {
        return _ref2.apply(this, arguments);
      }

      return getIncrementFromPullRequest;
    }()
  }, {
    key: "increment",
    value: function () {
      var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
        var spinners, lastChange, branch, newVersion, range, commit, _commit$split, _commit$split2, name, email, message, appendSuccess;

        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                spinners = [];


                spinners.push((0, _ora2.default)("Getting last change and determining the current version").start());
                _context3.next = 4;
                return this.getLastChangeWithIncrement();

              case 4:
                lastChange = _context3.sent;

                if (!(lastChange.increment === Version.NO_INCREMENT)) {
                  _context3.next = 9;
                  break;
                }

                spinners[0].succeed();
                debug.warn("Found internal label. Aborting release.");
                return _context3.abrupt("return", false);

              case 9:
                branch = _Utils2.default.getBranch();
                newVersion = _Utils2.default.incrementVersion(lastChange.increment, this.config.version);

                spinners[0].succeed();

                debug.info("Bumping v" + this.config.version + " with " + lastChange.increment + " release...");

                // override the git user/email based on last commit

                if (!(process.env.CI && !this.options.dryRun)) {
                  _context3.next = 23;
                  break;
                }

                range = _Utils2.default.getCommitRange();
                commit = _Utils2.default.exec("git log -n1 --format='%an|%ae|%s' " + range).shift();

                if (commit) {
                  _context3.next = 19;
                  break;
                }

                debug.warn("No merge commits found between: %s", range);
                throw new Error("No commits found in " + range);

              case 19:
                _commit$split = commit.split("|"), _commit$split2 = (0, _slicedToArray3.default)(_commit$split, 3), name = _commit$split2[0], email = _commit$split2[1], message = _commit$split2[2];


                debug.info("Overriding default git user/email options");

                _Utils2.default.exec("git config user.name \"" + name + "\"");
                _Utils2.default.exec("git config user.email \"" + email + "\"");

              case 23:

                if (this.shouldPush && !this.options.dryRun) {
                  debug.info("Checking out the " + branch + " branch");
                  _Utils2.default.exec("git checkout " + branch);
                }

                if (!this.options.dryRun) {
                  spinners.push((0, _ora2.default)("Incrementing the version in package.json with " + lastChange.increment).start());
                  _Utils2.default.exec("npm version " + lastChange.increment + " --no-git-tag-version", { stdio: "ignore" });
                  spinners[1].succeed();
                } else {
                  debug.warn("[DRY RUN] bumping package version with " + lastChange.increment);
                }

                if (this.shouldPush && !this.options.dryRun) {
                  debug.info("Adding package.json to commit list");
                  _Utils2.default.exec("git add package.json");
                }

                if (this.options.changelog) {
                  appendSuccess = true;

                  try {
                    this.appendChangeLog(newVersion, lastChange);
                  } catch (err) {
                    debug.warn("Skipping appending to CHANGELOG -- no current CHANGELOG.md found.");
                    appendSuccess = false;
                  }

                  if (appendSuccess && this.shouldPush && !this.options.dryRun) {
                    debug.info("Adding CHANGELOG.md to the commit list");
                    _Utils2.default.exec("git add CHANGELOG.md");
                  }
                }

                if (this.shouldPush && !this.options.dryRun) {
                  spinners.push((0, _ora2.default)("Committing the changes and tagging a new version").start());
                  debug.info("Committing the current changes and tagging new version");
                  _Utils2.default.exec("git commit -m \"Automated release: v" + newVersion + "\n\n[ci skip]\"");
                  _Utils2.default.exec("git tag v" + newVersion);
                  spinners[2].succeed();
                }

                return _context3.abrupt("return", true);

              case 29:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function increment() {
        return _ref3.apply(this, arguments);
      }

      return increment;
    }()
  }, {
    key: "publish",
    value: function () {
      var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
        var spinner;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this.config.private) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return", debug.warn("This package is marked private -- skipping NPM publish"));

              case 2:
                if (!this.options.dryRun) {
                  _context4.next = 4;
                  break;
                }

                return _context4.abrupt("return", debug.warn("[DRY RUN] publishing to NPM"));

              case 4:
                spinner = (0, _ora2.default)("Publishing to NPM");

                _Utils2.default.exec("npm publish");
                spinner.succeed();

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function publish() {
        return _ref4.apply(this, arguments);
      }

      return publish;
    }()
  }, {
    key: "push",
    value: function () {
      var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
        var spinner, _Utils$getUserRepo, user, repo, _config$github, _config$github$protoc, protocol, _config$github$host, host, token, origin;

        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this.options.dryRun) {
                  _context5.next = 2;
                  break;
                }

                return _context5.abrupt("return", debug.warn("[DRY RUN] Pushing changes to master branch"));

              case 2:
                spinner = (0, _ora2.default)("Pushing changes to Github").start();


                if (process.env.CI && process.env.GH_TOKEN) {
                  _Utils$getUserRepo = _Utils2.default.getUserRepo(), user = _Utils$getUserRepo.user, repo = _Utils$getUserRepo.repo;
                  _config$github = this.config.github, _config$github$protoc = _config$github.protocol, protocol = _config$github$protoc === undefined ? 'https' : _config$github$protoc, _config$github$host = _config$github.host, host = _config$github$host === undefined ? 'github.com' : _config$github$host;
                  token = '${GH_TOKEN}';
                  origin = protocol + "://" + user + ":" + token + "@" + host + "/" + user + "/" + repo + ".git";


                  debug.info("Explicitly setting git origin to: " + origin);
                  _Utils2.default.exec("git remote set-url origin " + origin);
                }

                _Utils2.default.exec("git push origin master --tags", { stdio: "ignore" });

                spinner.succeed();

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function push() {
        return _ref5.apply(this, arguments);
      }

      return push;
    }()
  }, {
    key: "getPullRequestCommits",
    value: function () {
      var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7(prs) {
        var _this = this;

        var githubapi, prCommits;
        return _regenerator2.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                githubapi = this.getGithubAPI();
                prCommits = prs.map(function () {
                  var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(pr) {
                    var commits;
                    return _regenerator2.default.wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _context6.next = 2;
                            return githubapi.getCommitsFromPullRequest(pr.number);

                          case 2:
                            commits = _context6.sent;
                            return _context6.abrupt("return", [].concat((0, _toConsumableArray3.default)(commits)));

                          case 4:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6, _this);
                  }));

                  return function (_x3) {
                    return _ref7.apply(this, arguments);
                  };
                }());
                return _context7.abrupt("return", _promise2.default.all(prCommits));

              case 3:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getPullRequestCommits(_x2) {
        return _ref6.apply(this, arguments);
      }

      return getPullRequestCommits;
    }()
  }, {
    key: "getRepoTimeline",
    value: function () {
      var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8() {
        var githubapi, allIssues, allCommits, allPRCommits, independentCommits, theTimeline;
        return _regenerator2.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!this.timeline) {
                  _context8.next = 2;
                  break;
                }

                return _context8.abrupt("return", this.timeline);

              case 2:
                githubapi = this.getGithubAPI();

                debug.info("Fetching all merged pull requests for the repo...");
                _context8.next = 6;
                return githubapi.searchIssues({ state: "closed", type: "pr", is: "merged" });

              case 6:
                allIssues = _context8.sent;

                debug.info("Merged pull requests fetched: " + allIssues.length);
                debug.info("Fetching all commits for the repo (yep, ALL commits)...");
                _context8.next = 11;
                return githubapi.getCommitsFromRepo();

              case 11:
                allCommits = _context8.sent;

                debug.info("Commits fetched: " + allCommits.length);

                // populate the commits for each pull request
                debug.info("Fetching the commits associated with the pull requests.");
                _context8.t0 = _lodash.flattenDeep;
                _context8.next = 17;
                return this.getPullRequestCommits(allIssues);

              case 17:
                _context8.t1 = _context8.sent;
                allPRCommits = (0, _context8.t0)(_context8.t1);

                debug.info("Commits (attached to PRs) fetched: " + allPRCommits.length);

                // get a list of commits not part of any pull requests
                // and not in the form of "Merge pull request #"
                // and not part of any automatic release
                independentCommits = allCommits.filter(function (commit) {
                  return !commit.message.match(/^Merge pull request #/);
                }).filter(function (commit) {
                  return !commit.message.match(/^Automated Release: v/i);
                }).filter(function (commit) {
                  return !commit.message.match(/\[ci skip\]/);
                }).filter(function (commit) {
                  return !commit.message.match(/\[skip ci\]/);
                }).filter(function (commit) {
                  return !(0, _lodash.find)(allPRCommits, function (prc) {
                    return prc === commit.sha;
                  });
                });
                theTimeline = (0, _lodash.orderBy)([].concat((0, _toConsumableArray3.default)(allIssues), (0, _toConsumableArray3.default)(independentCommits)), ['date'], ['asc']);


                this.timeline = theTimeline;

                return _context8.abrupt("return", theTimeline);

              case 24:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getRepoTimeline() {
        return _ref8.apply(this, arguments);
      }

      return getRepoTimeline;
    }()
  }, {
    key: "getGithubAPI",
    value: function getGithubAPI() {
      return new _Github2.default(_Utils2.default.getUserRepo(), this.config.github);
    }
  }, {
    key: "getIncrementFromIssueLabels",
    value: function getIncrementFromIssueLabels(issue) {
      var _this2 = this;

      var regex = new RegExp("^" + this.config.majorLabel + "|^" + this.config.minorLabel + "|^" + this.config.patchLabel + "|^" + this.config.internalLabel);
      // commits won't have labels property
      return issue.labels ? issue.labels.map(function (label) {
        return label.name;
      }).filter(function (name) {
        return name.match(regex);
      }).map(function (increment) {
        return _this2.incrementMap[increment];
      }).shift() : undefined;
      ;
    }

    // not static because we need the config option passed into the constructor

  }, {
    key: "getVersionFromTimeline",
    value: function getVersionFromTimeline(timeline) {
      var _this3 = this;

      var version = this.config.startVersion || "0.0.0";

      timeline.forEach(function (event) {
        var increment = _this3.getIncrementFromIssueLabels(event);
        version = _Utils2.default.incrementVersion(increment, version);
      });

      return version;
    }
  }, {
    key: "getChangeLogContents",
    value: function () {
      var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9() {
        var _this4 = this;

        var spinner, githubapi, allEvents, lines, version, lastEventDate;
        return _regenerator2.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                spinner = (0, _ora2.default)("Generating the changelog contents").start();
                githubapi = this.getGithubAPI();
                _context9.next = 4;
                return this.getRepoTimeline();

              case 4:
                allEvents = _context9.sent;
                lines = [];
                version = this.config.startVersion || "0.0.0";
                lastEventDate = (0, _moment2.default)(allEvents[0].date).format("YYYY-MM-DD");


                allEvents.forEach(function (issue) {
                  var currentEventDate = (0, _moment2.default)(issue.date).format("YYYY-MM-DD");

                  if (currentEventDate !== lastEventDate) {
                    lines.push("\n## " + lastEventDate + "\n\n");
                  }

                  var increment = _this4.getIncrementFromIssueLabels(issue);
                  version = _Utils2.default.incrementVersion(increment, version);
                  lines.push(_Utils2.default.getChangeLogLine(version, issue, increment) + "\n");
                  lastEventDate = currentEventDate;
                });

                lines.push("## " + lastEventDate + " - [" + version + " - current version]\n\n");
                lines.push(_Utils2.default.getChangeLogHeader());

                spinner.succeed();

                return _context9.abrupt("return", (0, _lodash.reverse)(lines));

              case 13:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getChangeLogContents() {
        return _ref9.apply(this, arguments);
      }

      return getChangeLogContents;
    }()
  }, {
    key: "appendChangeLog",
    value: function appendChangeLog(newVersion, lastChange) {
      if (this.options.dryRun) {
        return debug.warn("[DRY RUN] appending \"" + _Utils2.default.getChangeLogLine(newVersion, lastChange) + "\" to CHANGELOG");
      }

      var spinner = (0, _ora2.default)("Appending latest change to CHANGELOG contents").start();
      var contents = _fsExtra2.default.readFileSync("CHANGELOG.md", "utf8", function (err, data) {
        if (err) {
          spinner.fail();
          throw err;
        }

        return data;
      });

      if (!contents) {
        spinner.fail();
        return debug.warn("Skipping appending CHANGELOG.md -- can't find a current CHANGELOG\"");
      }

      var lines = contents.split("\n");

      var newLines = lines.slice(0, 5);
      newLines.push("## " + (0, _moment2.default)().format("YYYY-MM-DD") + " - [" + newVersion + " - current version]");
      newLines.push("");
      newLines.push(_Utils2.default.getChangeLogLine(newVersion, lastChange));

      // if latest change is the same date
      if ((0, _moment2.default)(lines[5].slice(3, 13)).isSame((0, _moment2.default)(), "day")) {
        newLines = newLines.concat(lines.slice(7));
      } else {
        newLines.push("");
        newLines.push(lines[5].slice(0, 13));
        newLines = newLines.concat(lines.slice(6));
      }

      spinner.succeed();
      this.writeChangeLog(newLines.map(function (line) {
        return line + "\n";
      }));
    }
  }, {
    key: "calculateCurrentVersion",
    value: function () {
      var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10() {
        var spinner, allEvents, version;
        return _regenerator2.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                spinner = (0, _ora2.default)("Calculating the repo's current version").start();
                _context10.next = 3;
                return this.getRepoTimeline();

              case 3:
                allEvents = _context10.sent;
                version = this.getVersionFromTimeline(allEvents);

                spinner.succeed();

                return _context10.abrupt("return", version);

              case 7:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function calculateCurrentVersion() {
        return _ref10.apply(this, arguments);
      }

      return calculateCurrentVersion;
    }()
  }, {
    key: "writeChangeLog",
    value: function writeChangeLog(lines) {
      if (this.options.dryRun) {
        debug.warn("[DRY RUN] writing changelog");
        return debug.warn((0, _lodash.join)(lines, ""));
      }

      var spinner = (0, _ora2.default)("Writing the contents of the changelog").start();

      _fsExtra2.default.writeFileSync("CHANGELOG.md", (0, _lodash.join)(lines, ""), { encoding: "utf8" }, function (err) {
        if (err) {
          spinner.fail();
          throw new Error("Problem writing CHANGELOG.md to file!");
        }
      });

      spinner.succeed();
    }
  }, {
    key: "commitRefreshedChanges",
    value: function commitRefreshedChanges(version) {
      var branch = _Utils2.default.getBranch();

      if (this.options.dryRun) {
        return debug.warn("[DRY RUN] Bumping package version & committing changes");
      }

      var spinner = (0, _ora2.default)("Committing the refreshed changes").start();

      debug.info("git checkout " + branch);
      _Utils2.default.exec("git checkout " + branch);
      debug.info("npm version " + version + " --no-git-tag-version");
      _Utils2.default.exec("npm version " + version + " --no-git-tag-version", { stdio: "ignore" });
      debug.info("git add package.json");
      _Utils2.default.exec("git add package.json");
      debug.info("git add CHANGELOG.md");
      _Utils2.default.exec("git add CHANGELOG.md");
      debug.info("git commit -m \"Automated release: v" + version + "\n\n[ci skip]\"");
      _Utils2.default.exec("git commit -m \"Automated release: v" + version + "\n\n[ci skip]\"");
      debug.info("git tag v" + version);
      _Utils2.default.exec("git tag v" + version);

      spinner.succeed();
    }

    // meant to be used after a successful CI build.

  }, {
    key: "release",
    value: function () {
      var _ref11 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee11() {
        var status;
        return _regenerator2.default.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.increment();

              case 2:
                status = _context11.sent;

                if (!(status && this.shouldPush)) {
                  _context11.next = 9;
                  break;
                }

                _context11.next = 6;
                return this.push();

              case 6:
                if (!this.shouldPublish) {
                  _context11.next = 9;
                  break;
                }

                _context11.next = 9;
                return this.publish();

              case 9:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function release() {
        return _ref11.apply(this, arguments);
      }

      return release;
    }()

    // meant to be used as a one off refresh of the changelog generation and version calculation

  }, {
    key: "refresh",
    value: function () {
      var _ref12 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee12() {
        var version, changeLog, versionsInSync, spinner;
        return _regenerator2.default.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.calculateCurrentVersion();

              case 2:
                version = _context12.sent;
                _context12.next = 5;
                return this.getChangeLogContents();

              case 5:
                changeLog = _context12.sent;

                if (_Utils2.default.validVersionBump(this.config.version, version)) {
                  _context12.next = 11;
                  break;
                }

                console.log("\n" + _chalk2.default.bold.red("WARNING!"));
                console.log("The current version listed in package.json (" + _chalk2.default.bold.cyan("" + this.config.version) + ") is > the calculated version (" + _chalk2.default.bold.cyan("" + version) + ").");
                console.log("To ensure a consistent changelog, either make use of " + _chalk2.default.bold.red("startVersion") + " in your package.json, or label existing PRs as you would expect them to affect the repo version.\n");

                return _context12.abrupt("return");

              case 11:

                // if versions are the same:
                // disallow the use of --push or --publish. this needs to be manual.
                versionsInSync = _Utils2.default.versionsInSync(this.config.version, version);


                if (versionsInSync) {
                  console.log("\n" + _chalk2.default.bold.cyan("HEADS UP!"));
                  console.log("The current version listed in package.json is the same as the calculated version: " + _chalk2.default.bold.cyan("" + version) + ".");
                  console.log("Use of --push and --publish will be ignored and you'll need to manually commit and push these changes to your repo.\n");
                  this.shouldPush = false;
                  this.shouldPublish = false;
                }

                if (!versionsInSync) {
                  if (this.options.dryRun) {
                    debug.warn("[DRY RUN] Setting the version in package.json to " + version);
                  } else {
                    debug.info("Setting the version in package.json to " + version);
                    spinner = (0, _ora2.default)("Setting the version in package.json to " + version).start();

                    _Utils2.default.exec("npm version " + version + " --no-git-tag-version", { stdio: "ignore" });
                    spinner.succeed();
                  }
                }

                this.writeChangeLog(changeLog);

                if (!this.shouldPush) {
                  _context12.next = 22;
                  break;
                }

                this.commitRefreshedChanges(version);
                _context12.next = 19;
                return this.push();

              case 19:
                if (!this.shouldPublish) {
                  _context12.next = 22;
                  break;
                }

                _context12.next = 22;
                return this.publish();

              case 22:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function refresh() {
        return _ref12.apply(this, arguments);
      }

      return refresh;
    }()
  }, {
    key: "check",
    value: function () {
      var _ref13 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee13() {
        var spinner, number, checkSpinner, labels, foundLabel;
        return _regenerator2.default.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                spinner = (0, _ora2.default)("Getting pull request number from environment").start();
                number = _Utils2.default.getPullRequestNumber();

                if (!(number && number.match(/^\d+$/))) {
                  _context13.next = 7;
                  break;
                }

                spinner.succeed();
                debug.info("Found PR #" + number);
                _context13.next = 9;
                break;

              case 7:
                spinner.fail();

                throw new Error("PR number could not be found within env vars");

              case 9:
                checkSpinner = (0, _ora2.default)("Checking for required labels").start();
                _context13.next = 12;
                return this.getGithubAPI().getIssueLabels(number);

              case 12:
                labels = _context13.sent;

                if (labels.length) {
                  _context13.next = 16;
                  break;
                }

                checkSpinner.fail();

                throw new Error("No labels found on the pull request");

              case 16:
                _context13.next = 18;
                return this.getIncrementFromIssueLabels({ labels: labels });

              case 18:
                foundLabel = _context13.sent;

                if (foundLabel) {
                  _context13.next = 22;
                  break;
                }

                checkSpinner.fail();

                throw new Error("Required label not found, must be one of: " + (0, _keys2.default)(this.incrementMap).join(', '));

              case 22:

                checkSpinner.succeed();
                debug.info("Found label \"" + foundLabel + "\" on PR");

              case 24:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function check() {
        return _ref13.apply(this, arguments);
      }

      return check;
    }()
  }]);
  return Version;
}();

Version.defaultOptions = {
  branch: "master"
};
Version.INCREMENT_MAJOR = "major";
Version.INCREMENT_MINOR = "minor";
Version.INCREMENT_PATCH = "patch";
Version.NO_INCREMENT = "none";
exports.default = Version;
;