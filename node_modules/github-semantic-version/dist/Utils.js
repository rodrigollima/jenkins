"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _os = require("os");

var _child_process = require("child_process");

var _fsExtra = require("fs-extra");

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _lodash = require("lodash");

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _semver = require("semver");

var _semver2 = _interopRequireDefault(_semver);

var _debug = require("./debug");

var debug = _interopRequireWildcard(_debug);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Utils = function () {
  function Utils() {
    (0, _classCallCheck3.default)(this, Utils);
  }

  (0, _createClass3.default)(Utils, null, [{
    key: "exec",
    value: function exec(cmd) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      debug.info("Executing: " + cmd);

      // Execute command, split lines, & trim empty ones
      var output = (0, _child_process.execSync)(cmd, (0, _extends3.default)({
        env: process.env
      }, options));

      return (output || "").toString().split(_os.EOL).filter(Boolean);
    }
  }, {
    key: "getBranch",
    value: function getBranch() {
      var branch = process.env.BRANCH || process.env.CIRCLE_BRANCH || process.env.TRAVIS_BRANCH || process.env.BUILDKITE_BRANCH;

      if (branch) {
        return branch;
      }

      var headFile = _path2.default.join(process.cwd(), ".git", "HEAD");
      var headContents = _fsExtra2.default.readFileSync(headFile, "utf8");

      var _ref = headContents.match(/ref: refs\/heads\/([^\n]+)/) || [],
          _ref2 = (0, _slicedToArray3.default)(_ref, 2),
          _ = _ref2[0],
          name = _ref2[1];

      return name;
    }
  }, {
    key: "getPullRequestNumber",
    value: function getPullRequestNumber() {
      return process.env.PULL_REQUEST || process.env.CIRCLE_PR_NUMBER || process.env.TRAVIS_PULL_REQUEST || process.env.BUILDKITE_PULL_REQUEST;
    }
  }, {
    key: "getCommitRange",
    value: function getCommitRange() {
      return [Utils.getLatestTag() || Utils.getInitialCommit(), "HEAD"].join("..");
    }
  }, {
    key: "getInitialCommit",
    value: function getInitialCommit() {
      return Utils.exec("git log --format=%h --max-parents=0 HEAD").filter(Boolean).pop();
    }
  }, {
    key: "getLastCommit",
    value: function getLastCommit() {
      return Utils.exec("git log -1 --format=%h HEAD").filter(Boolean).pop();
    }
  }, {
    key: "getLastPullRequest",
    value: function getLastPullRequest() {
      var range = Utils.getCommitRange();

      // Merge commits
      var commits = Utils.exec("git log --merges -n1 --format='%an|%ae|%s' " + range);

      if (!commits.length) {
        debug.warn("No merge commits found between: %s", range);
        debug.info("Checking for squash commits.");
      }

      // Squash commits
      commits = Utils.exec("git log --format='%an|%ae|%s' " + range);

      if (!commits.length) {
        debug.warn("No squash commits found between: %s", range);
        return null;
      }

      // Parse and detect
      var pr = void 0;

      try {
        commits.some(function (commit) {
          var _commit$split = commit.split("|"),
              _commit$split2 = (0, _slicedToArray3.default)(_commit$split, 3),
              name = _commit$split2[0],
              email = _commit$split2[1],
              message = _commit$split2[2];

          if (!message) {
            throw new Error("Could not parse name, email, & message from: " + commit);
          }

          var match = message.match(/^Merge pull request #(\d+)|\(#(\d+)\)$/) || [];

          // 2 = squash, 1 = merge
          pr = match[2] || match[1];

          return !!pr;
        });
      } catch (error) {
        return debug.error(error.message);
      }

      return pr;
    }
  }, {
    key: "getLatestTag",
    value: function getLatestTag() {
      var tag = Utils.exec("git fetch --tags && git tag -l v*").filter(function (tag) {
        return tag.match(/^v(\d+)\.(\d+)\.(\d)/);
      }).pop();

      if (tag) {
        debug.info("Latest tag: %s", tag);
      } else {
        debug.warn("No tags found");
      }

      return tag || null;
    }
  }, {
    key: "getUserRepo",
    value: function getUserRepo() {
      var _Utils$exec$shift$rep = Utils.exec("git config --get remote.origin.url").shift().replace(".git", "").split(/\/|:/).slice(-2),
          _Utils$exec$shift$rep2 = (0, _slicedToArray3.default)(_Utils$exec$shift$rep, 2),
          user = _Utils$exec$shift$rep2[0],
          repo = _Utils$exec$shift$rep2[1];

      debug.info("User: %s", user);
      debug.info("Repo: %s", repo);

      return { user: user, repo: repo };
    }
  }, {
    key: "getChangeLogHeader",
    value: function getChangeLogHeader() {
      var headerLines = [];

      headerLines.push("# Change Log\n");
      headerLines.push("All notable changes to this project will be documented in this file.\n\n");
      headerLines.push("This project adheres to [Semantic Versioning](http://semver.org/).\n\n");

      return (0, _lodash.join)(headerLines, "");
    }
  }, {
    key: "getChangeLogLine",
    value: function getChangeLogLine(version, issue) {
      var increment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

      var issueNumber = issue.number ? "[" + issue.number + "]" : "[" + issue.sha.slice(0, 7) + "]";
      var issueUrl = "(" + issue.url + ")";
      var title = "" + (issue.title ? issue.title : issue.message.replace(/\n/g, " "));
      var user = issue.user ? "(@" + issue.user + ")" : "(" + issue.userName + ")";
      var inc = increment || issue.increment || '';

      return "- " + (inc === 'none' ? '[internal]' : version) + " - (" + issueNumber + issueUrl + ") - " + title + " " + user;
    }
  }, {
    key: "incrementVersion",
    value: function incrementVersion(increment, version) {
      var inc = increment || "patch";

      if (inc === 'none') {
        return version;
      }

      return _semver2.default.inc(version, inc);
    }
  }, {
    key: "validVersionBump",
    value: function validVersionBump(oldVersion, newVersion) {
      return _semver2.default.gte(newVersion, oldVersion);
    }
  }, {
    key: "versionsInSync",
    value: function versionsInSync(oldVersion, newVersion) {
      return _semver2.default.eq(newVersion, oldVersion);
    }
  }, {
    key: "getOptionsFromFile",
    value: function getOptionsFromFile(configFilePath) {
      if (configFilePath) {
        try {
          var filePath = _path2.default.resolve(process.cwd(), configFilePath);
          return _fsExtra2.default.readJsonSync(filePath);
        } catch (err) {}
      }
    }
  }]);
  return Utils;
}();

exports.default = Utils;