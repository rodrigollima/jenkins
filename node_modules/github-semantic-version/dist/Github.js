"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _rest = require("@octokit/rest");

var _rest2 = _interopRequireDefault(_rest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GithubAPI = function () {
  function GithubAPI(userRepo) {
    var apiOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, GithubAPI);

    this.defaultOptions = {
      owner: userRepo.user,
      repo: userRepo.repo
    };

    this.github = new _rest2.default(apiOptions);

    // this buys you 5000 requests an hour in all but the Search API, where you get 30 requests/min
    var token = process.env.GH_TOKEN || process.env.GITHUB_TOKEN;

    if (token) {
      this.github.authenticate({
        token: token,
        type: "oauth"
      });
    }
  }

  (0, _createClass3.default)(GithubAPI, [{
    key: "getCommit",
    value: function () {
      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(hash) {
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.github.repos.getCommit((0, _extends3.default)({}, this.defaultOptions, { sha: hash })).then(function (_ref2) {
                  var commit = _ref2.data;

                  return {
                    date: commit.commit.author.date,
                    sha: commit.sha,
                    user: commit.author ? commit.author.login : undefined,
                    userName: commit.commit.author.name,
                    message: commit.commit.message,
                    url: commit.html_url
                  };
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getCommit(_x2) {
        return _ref.apply(this, arguments);
      }

      return getCommit;
    }()
  }, {
    key: "getPullRequest",
    value: function () {
      var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(prNumber) {
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.github.pullRequests.get((0, _extends3.default)({}, this.defaultOptions, { number: prNumber })).then(function (_ref4) {
                  var pr = _ref4.data;

                  return {
                    date: pr.merged_at,
                    user: pr.user.login,
                    title: pr.title,
                    number: pr.number,
                    url: pr.html_url
                  };
                }));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getPullRequest(_x3) {
        return _ref3.apply(this, arguments);
      }

      return getPullRequest;
    }()
  }, {
    key: "getIssueLabels",
    value: function () {
      var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(issueNumber) {
        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", this.github.issues.getIssueLabels((0, _extends3.default)({}, this.defaultOptions, { number: issueNumber })).then(function (_ref6) {
                  var issues = _ref6.data;
                  return issues;
                }));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getIssueLabels(_x4) {
        return _ref5.apply(this, arguments);
      }

      return getIssueLabels;
    }()

    // convert query object to a string in the format: searchProperty1:searchValue1 [searchPropertyN:searchValueN]

  }, {
    key: "formatSearchString",
    value: function formatSearchString(query) {
      var q = "repo:" + this.defaultOptions.owner + "/" + this.defaultOptions.repo;

      for (var key in query) {
        if (query.hasOwnProperty(key)) {
          q += " " + key + ":\"" + query[key] + "\"";
        }
      }

      return q.trim();
    }
  }, {
    key: "searchIssues",
    value: function () {
      var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(query) {
        var _this = this;

        var q, allIssues, concatAndPage;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                // the search string takes the format: searchProperty1:searchValue1 [searchPropertyN:searchValueN]
                q = this.formatSearchString(query);
                allIssues = [];

                concatAndPage = function concatAndPage(response) {
                  response.data.items.forEach(function (issue) {
                    allIssues.push({
                      date: issue.closed_at,
                      user: issue.user.login,
                      title: issue.title,
                      labels: issue.labels,
                      number: issue.number,
                      url: issue.html_url
                    });
                  });

                  if (_this.github.hasNextPage(response)) {
                    return _this.github.getNextPage(response).then(concatAndPage);
                  } else {
                    return allIssues;
                  }
                };

                return _context4.abrupt("return", this.github.search.issues({ per_page: 100, q: q }).then(concatAndPage));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function searchIssues(_x5) {
        return _ref7.apply(this, arguments);
      }

      return searchIssues;
    }()
  }, {
    key: "getCommitsFromPullRequest",
    value: function () {
      var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(prNumber) {
        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this.github.pullRequests.getCommits((0, _extends3.default)({}, this.defaultOptions, {
                  number: prNumber,
                  per_page: 100
                })).then(function (_ref9) {
                  var commits = _ref9.data;

                  return commits.map(function (c) {
                    return c.sha;
                  });
                }));

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getCommitsFromPullRequest(_x6) {
        return _ref8.apply(this, arguments);
      }

      return getCommitsFromPullRequest;
    }()
  }, {
    key: "getCommitsFromRepo",
    value: function () {
      var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
        var _this2 = this;

        var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var allCommits, concatAndPage;
        return _regenerator2.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                allCommits = [];

                concatAndPage = function concatAndPage(response) {
                  response.data.forEach(function (commit) {
                    allCommits.push({
                      date: commit.commit.author.date, // some heirarchy
                      sha: commit.sha,
                      user: commit.author ? commit.author.login : undefined,
                      userName: commit.commit.author.name,
                      message: commit.commit.message,
                      url: commit.html_url
                    });
                  });

                  if (_this2.github.hasNextPage(response)) {
                    return _this2.github.getNextPage(response).then(concatAndPage);
                  } else {
                    return allCommits;
                  }
                };

                return _context6.abrupt("return", this.github.repos.getCommits((0, _extends3.default)({}, this.defaultOptions, query)).then(concatAndPage));

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getCommitsFromRepo() {
        return _ref10.apply(this, arguments);
      }

      return getCommitsFromRepo;
    }()
  }]);
  return GithubAPI;
}();

exports.default = GithubAPI;
;